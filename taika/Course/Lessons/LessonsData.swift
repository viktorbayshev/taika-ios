//
//  LessonsData.swift
//  taika
//
//  Created by product on 25.08.2025.
//


//
//  LessonsData.swift
//  taika
//
//  Autogenerated on request: parses lessons.json (v1) and provides typed access.
//

import Foundation
import Combine

// MARK: - Public entrypoint

final class LessonsData: ObservableObject {
    static let shared = LessonsData()

    @Published private(set) var bundle: LessonsBundle = .empty

    private var loadOnce = Once()

    /// Call early (e.g., on app start) or rely on lazy loading via accessors.
    func preload() {
        loadOnce.perform { [weak self] in
            do {
                let loaded = try LessonsLoader.load()
                // publish immediately when we're already on main thread (prevents a 1-runloop "empty bundle" window)
                if Thread.isMainThread {
                    self?.bundle = loaded
                } else {
                    DispatchQueue.main.async { [weak self] in
                        self?.bundle = loaded
                    }
                }
            } catch {
                print("Ошибка парсинга lessons.json")
                if case DecodingError.dataCorrupted(let ctx) = error {
                    print("dataCorrupted at path: \(ctx.codingPath.map { $0.stringValue }.joined(separator: ".")) — \(ctx.debugDescription)")
                } else if case DecodingError.keyNotFound(let key, let ctx) = error {
                    print("keyNotFound: \(key.stringValue) at path: \(ctx.codingPath.map { $0.stringValue }.joined(separator: ".")) — \(ctx.debugDescription)")
                } else if case DecodingError.typeMismatch(_, let ctx) = error {
                    print("typeMismatch at path: \(ctx.codingPath.map { $0.stringValue }.joined(separator: ".")) — \(ctx.debugDescription)")
                } else if case DecodingError.valueNotFound(_, let ctx) = error {
                    print("valueNotFound at path: \(ctx.codingPath.map { $0.stringValue }.joined(separator: ".")) — \(ctx.debugDescription)")
                } else {
                    let ns = error as NSError
                    print("decode error: \(error) userInfo=\(ns.userInfo)")
                }
                self?.bundle = .empty
            }
        }
    }

    // Convenience accessors -------------------------------------------------

    func allCourses() -> [CourseBundle] { ensureLoaded(); return bundle.courses }

    func course(id: String) -> CourseBundle? {
        ensureLoaded();
        return bundle.courses.first { $0.courseID == id }
    }

    func lessons(for courseID: String) -> [LessonBundle] {
        course(id: courseID)?.lessons ?? []
    }

    func lesson(courseID: String, lessonID: String) -> LessonBundle? {
        lessons(for: courseID).first { $0.lessonID == lessonID }
    }

    /// Returns the localized title for a lesson by its lessonID across all courses.
    func lessonTitle(for lessonID: String) -> String? {
        ensureLoaded()
        for course in bundle.courses {
            if let lesson = course.lessons.first(where: { $0.lessonID == lessonID }) {
                return lesson.title
            }
        }
        return nil
    }

    // ----------------------------------------------------------------------
    private func ensureLoaded() {
        preload()
        if bundle.courses.isEmpty {
            print("[LessonsData] bundle is empty after preload() — navigation may render empty state")
        }
    }
}

// MARK: - Loader

enum LessonsLoader {
    static func load(from bundle: Bundle = .main, fileName: String = "lessons", fileExtension: String = "json") throws -> LessonsBundle {
        guard let url = bundle.url(forResource: fileName, withExtension: fileExtension) else {
            throw LessonsDataError.fileNotFound("\(fileName).\(fileExtension)")
        }
        print("[LessonsLoader] using: \(url.path)")

        let data = try Data(contentsOf: url)
        if let head = String(data: data.prefix(200), encoding: .utf8) {
            print("[LessonsLoader] head: \(head)")
        }

        let decoder = JSONDecoder()
        do {
            return try decoder.decode(LessonsBundle.self, from: data)
        } catch {
            debugValidateJSON(data: data, url: url)
            throw error
        }
    }

    /// дополнительный отладочный валидатор: если JSON не парсится,
    /// пытаемся прогнать его через JSONSerialization и печатаем подробности.
    private static func debugValidateJSON(data: Data, url: URL) {
        do {
            _ = try JSONSerialization.jsonObject(with: data, options: [])
        } catch {
            let ns = error as NSError
            print("[LessonsLoader] JSONSerialization error for \(url.lastPathComponent): \(ns.localizedDescription) userInfo=\(ns.userInfo)")
            if let raw = String(data: data, encoding: .utf8) {
                print("[LessonsLoader] raw length=\(raw.count) chars")
            }
        }
    }
}

enum LessonsDataError: Error, LocalizedError {
    case fileNotFound(String)

    var errorDescription: String? {
        switch self {
        case .fileNotFound(let name): return "Lessons JSON not found: \(name)"
        }
    }
}

// MARK: - Models (mirror lessons.json v1)

struct LessonsBundle: Codable, Equatable {
    let version: Int
    let courses: [CourseBundle]

    static let empty = LessonsBundle(version: 1, courses: [])
}

struct CourseBundle: Codable, Equatable, Identifiable {
    let courseID: String
    let courseTitle: String
    let lessons: [LessonBundle]
    let summary: CourseSummary?

    /// Bridged description from CourseData (by courseID); not stored in lessons.json
    var courseDescription: String? {
        // This relies on CourseData singleton present in the project
        return CourseData.shared.description(for: courseID)
    }

    var id: String { courseID }

    enum CodingKeys: String, CodingKey {
        case courseID = "course_id"
        case courseTitle = "course_title"
        case lessons
        case summary
        // fallbacks (legacy / alternative)
        case id
        case courseId
        case title
    }

    init(courseID: String, courseTitle: String, lessons: [LessonBundle], summary: CourseSummary?) {
        self.courseID = courseID
        self.courseTitle = courseTitle
        self.lessons = lessons
        self.summary = summary
    }

    init(from decoder: Decoder) throws {
        let c = try decoder.container(keyedBy: CodingKeys.self)
        // courseID: try multiple key variants
        if let v = try? c.decode(String.self, forKey: .courseID) {
            self.courseID = v
        } else if let v = try? c.decode(String.self, forKey: .courseId) {
            self.courseID = v
        } else if let v = try? c.decode(String.self, forKey: .id) {
            self.courseID = v
        } else {
            throw DecodingError.keyNotFound(CodingKeys.courseID, .init(codingPath: c.codingPath, debugDescription: "Neither course_id, courseId nor id present"))
        }
        // title: try course_title, then title
        if let t = try? c.decode(String.self, forKey: .courseTitle) {
            self.courseTitle = t
        } else if let t = try? c.decode(String.self, forKey: .title) {
            self.courseTitle = t
        } else {
            throw DecodingError.keyNotFound(CodingKeys.courseTitle, .init(codingPath: c.codingPath, debugDescription: "Neither course_title nor title present"))
        }
        self.lessons = (try? c.decode([LessonBundle].self, forKey: .lessons)) ?? []
        self.summary = try? c.decode(CourseSummary.self, forKey: .summary)
    }
    func encode(to encoder: Encoder) throws {
        var c = encoder.container(keyedBy: CodingKeys.self)
        try c.encode(courseID, forKey: .courseID)
        try c.encode(courseTitle, forKey: .courseTitle)
        try c.encode(lessons, forKey: .lessons)
        try c.encodeIfPresent(summary, forKey: .summary)
    }
}

struct CourseSummary: Codable, Equatable {
    let totalLessons: Int
    let totalDurationMinutes: Int
    
    enum CodingKeys: String, CodingKey {
        case totalLessons = "total_lessons"
        case totalDurationMinutes = "total_duration_minutes"
    }
}

struct LessonBundle: Codable, Equatable, Identifiable {
    let lessonID: String
    let order: Int
    let title: String
    let subtitle: String
    let durationMinutes: Int
    let cardCount: Int
    let isFree: Bool
    let tags: [String]
    let previewPhrase: String
    let content: [LessonContent]
    let outcomes: [String]
    let prerequisites: [String]
    let links: LessonLinks
    let assistantTips: [String]?

    var id: String { lessonID }

    // preview helpers ("ru;phonetic")
    var previewPrimary: String {
        splitPreviewPhrase().primary
    }

    var previewSecondary: String {
        splitPreviewPhrase().secondary
    }

    private func splitPreviewPhrase() -> (primary: String, secondary: String) {
        let raw = previewPhrase.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !raw.isEmpty else { return ("", "") }

        // 1) preferred format: "a;b"
        if raw.contains(";") {
            let parts = raw.split(separator: ";", maxSplits: 1, omittingEmptySubsequences: false)
            let a = parts.first.map { String($0).trimmingCharacters(in: .whitespacesAndNewlines) } ?? ""
            let b = parts.count > 1 ? String(parts[1]).trimmingCharacters(in: .whitespacesAndNewlines) : ""
            return (a.isEmpty ? raw : a, b)
        }

        // 2) legacy format: "left — right"
        if let r = raw.firstIndex(of: "—") {
            let left = String(raw[..<r]).trimmingCharacters(in: .whitespacesAndNewlines)
            let right = String(raw[raw.index(after: r)...]).trimmingCharacters(in: .whitespacesAndNewlines)

            // if right contains «...», use the quoted text as primary (title)
            if let ql = right.firstIndex(of: "«"), let qr = right[ql...].firstIndex(of: "»") {
                let inside = String(right[right.index(after: ql)..<qr]).trimmingCharacters(in: .whitespacesAndNewlines)
                if !inside.isEmpty {
                    return (inside, left.isEmpty ? "" : left)
                }
            }

            if !right.isEmpty {
                return (right, left)
            }
            return (left.isEmpty ? raw : left, "")
        }

        // 3) fallback: single line
        return (raw, "")
    }
    
    enum CodingKeys: String, CodingKey {
        case lessonID = "lesson_id"
        case order, title, subtitle
        case durationMinutes = "duration_minutes"
        case cardCount = "card_count"
        case isFree = "is_free"
        case tags
        case previewPhrase = "preview_phrase"
        case content, outcomes, prerequisites, links
        case assistantTips = "assistant_tips"
    }
}

struct LessonLinks: Codable, Equatable {
    let stepsRef: String
    let hometaskRef: String
    
    enum CodingKeys: String, CodingKey {
        case stepsRef = "steps_ref"
        case hometaskRef = "hometask_ref"
    }
}

struct LessonContent: Codable, Equatable {
    let kind: LessonContentKind
    let text: String
}

enum LessonContentKind: String, Codable {
    case intro, outline, apply, outcome
}

// MARK: - Small helpers

/// Executes a closure only once per instance lifecycle.
final class Once {
    private var didRun = false
    func perform(_ block: () -> Void) {
        guard !didRun else { return }
        didRun = true
        block()
    }
}
